<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>GeneralSkill on Kesa</title>
    <link>/categories/generalskill/</link>
    <description>Recent content in GeneralSkill on Kesa</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 17 Oct 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/categories/generalskill/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>作业|概率论小论文:几何概型应用</title>
      <link>/post/2018/10/17/the-geometric-model/</link>
      <pubDate>Wed, 17 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/2018/10/17/the-geometric-model/</guid>
      <description>学生信息:
   学号 姓名 班级     41522262 魏先 信计171    几何概型及应用: 从和古典概型的联系及测度总结到对贝特朗悖论和蒙特卡罗模拟的研究
文献综述 几何概型的应用在CNKI的搜索结果大多都与初高中数学教学相关,在这个领域的研究重点在于把握几何概形区分于古典概型的性质和依据这些特殊的性质的应用,以下的前一部分是对几份高中教学研讨文献综述的提取总结;另一方面仍然有少数文献针对高校数学专业学科问题讨论了一些问题,后一部分是对这些文献综述的提取总结.
文献1:(杨芝艳)几何概型与古典概型概念认识的统一性及几何概型的应用1 主要内容:节选自文章摘要
 摘要本文旨在将概率论基本概型之一的几何概型同经典的古典概型统一起来，对古典（几何）榄率定义、性质方面的统一性作了系统的论述，针对不同的问题给出了应用上较方便的计算方法，并运用例子说明几何概型（几何概率）在实际问题中的应用。
 文献2:(赵 曼)贝特朗悖论研究及其解悖方案2  贝特朗悖论是几何概率悖论。本文尝试性的对悖论产生的原因进行分析并构建解悖方案。给出正确的概率值为一个无限逼近于1/2的值，同时指出该悖论的三种经典方案给出的前提假设均是正确的，只是转化为计算方法时存在错误，指出了新的转化思路及算法，转化后使得另外两个思路下的概率值同样为一个趋近于1/2的值。同时用MATLAB对三种算法以及创新性的转化思路后的算法进行了模拟验证并给出计算模型的物理意义。本文的研究，对于贝特朗悖论研究的进一步发展提供了有益的借鉴。
 文献3:(何晓勤)几何概型测度的类型及应用3 主要内容:节选自文章摘要
 几何概型是一种特殊的随机事件概率模型，是概率问题的几何形式.求解此类问题时可把每个基本事件理解为从某个特定的可度量的几何区域D内随机取一点，区域D内的每一点被取到的可能性大小相同，即点在区域D内是均匀分布的;随机事件A发生则可理解为恰好取到区域D内的子区域d内的点，从而得到事件A发生的概率为 的测度的测度 $ P(A)=\frac{d的测度}{D的测度} $ .因此，解决几何概型问题的关键是确定点对应的几何区域，并正确计算相应区域的测度.高中阶段碰到的几何区域主要包括线段、射线、平面图形和立体图形，对应的测度分别为长度、角度、面积和体积.
 文献4:(杨 杰)几何概型的求解技巧与应用4 主要内容:节选自文章摘要
 此前, 已有很多学者对几何概型的求解及应用做了研 究, 得出了些相应的结论, 大大推动了概率论的不断前进. 在此文中主要是利用几何概型的定义来探讨此类概率的 一些求解技巧与应用, 并总结了其解题的一般步骤.这里 分为两类几何概型求解, 一类是样本空间的几何意义较明 显的几何概型; 一类是几何意义不明显的几何概型.前者 较简单, 易于求解; 后者较复杂, 求解富有技巧性.另外, 对 Buffon 投针做了进一步推广, 用正三角形代替针.
 文献5:(辛萍芳)均匀分布与几何概型在现代计算技术中的应用5  给出了均匀分布与几何概型的联系，以及在实际应用过程中各自的计算优势，并且介绍了均匀分布在现 代计算技术中的应用。</description>
    </item>
    
    <item>
      <title>LaTex|初步搞定LaTex</title>
      <link>/post/2018/10/05/jb-latex/</link>
      <pubDate>Fri, 05 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/2018/10/05/jb-latex/</guid>
      <description>历程 1. 从DashJay处获得本地渲染LaTex的需求 2. 把上次JSON给的远端Scripts换成从Node.js爬下来的本地Scripts 3. 更改/themes/hugo-ivy/layouts/_default/single.html处的地址  参考网站 LaTeX 各种命令&amp;amp;符号
以下总结from DashJay  希腊字母表格  大写字母若和英文字母相同则无法大写

   小写 大写 $ L^AT_EX $     α A \alpha   β B \beta   γ Γ \gamma   δ Δ \delta   ϵ E \epsilon   ζ Z \zeta   ν N \nu   ξ Ξ \xi   ο O \omicron   π Π \pi   ρ P \rho   σ Σ \sigma   η H \eta   θ Θ \theta   ι I \iota   κ K \kappa   λ Λ \lambda   μ M \mu   ϕ Φ \phi，（φφ：\varphi）   χ X \chi   ψ Ψ \psi   ω Ω \omega</description>
    </item>
    
    <item>
      <title>Hugo|搞定LaTex 计划新功能</title>
      <link>/post/2018/10/03/hugo%E6%90%9E%E5%AE%9Alatex-%E8%AE%A1%E5%88%92%E6%96%B0%E5%8A%9F%E8%83%BD/</link>
      <pubDate>Wed, 03 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/2018/10/03/hugo%E6%90%9E%E5%AE%9Alatex-%E8%AE%A1%E5%88%92%E6%96%B0%E5%8A%9F%E8%83%BD/</guid>
      <description> 致谢:
 Json
Dash J(G)ay
 很难受的LaTex落地过程 1. 从Json那里搞到了源代码超级牛逼 &amp;lt;!--致谢Json的LaTex源--&amp;gt; &amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&amp;quot;&amp;gt; MathJax.Hub.Config({ tex2jax: { displayMath: [[&#39;$$&#39;,&#39;$$&#39;],[&amp;quot;\\(&amp;quot;,&amp;quot;\\)&amp;quot;]], inlineMath: [[&#39;\\[&#39;,&#39;\\]&#39;], [&#39;$&#39;,&#39;$&#39;]], }, }); &amp;lt;/script&amp;gt; &amp;lt;!--致谢Json的LaTex源--&amp;gt;  2. 搞到了关键的目录(前期被Dash Gay后期率先反杀) 一开始我搞错了目录 后来找到了 纠正了Jay在_default.md中放置&amp;lt;script&amp;gt;的错误 在themes/hugo-ivy/layout/single 中间加入了目标 不过不是Gay帮我也很可能发现不了问题啦  3. 计划一下今后对Blog改造的重点导向 1. 字体问题: 1.1. 要不要学谢大搞一个字体后处理渲染 2. 自定义MarkDown解析器: 2.1. 解决居中文本的方便解决方案 2.2. 解决全套Markdown的自定义配置(说说而已) 3. 插入多媒体 3.1. 插入视频/音频链接 3.2. 插入固定视频/音频 4. 更加多元的博客配置 4.1. 能够在主题之外定义架构并自由制作不受Hugo的MarkDown约束的网页  </description>
    </item>
    
    <item>
      <title>未完待续_CSharp|&lt;&lt;编写高质量C#代码建议&gt;&gt;提炼</title>
      <link>/post/2018/09/01/c-c/</link>
      <pubDate>Sat, 01 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/2018/09/01/c-c/</guid>
      <description>总结:  StopWatch 和 Time.DeltaTime 的比较  了解StopWatch这个数据类型也是用来做时长判断的 Stopwatch 和 DateTime 对比 : 具体用法见下面的详情  StopWatch就是个计时器 DateTime是了解从年月日时分秒毫秒的    StopWatch 和 Time.DeltaTime 的比较 在看到几次作者尝试调试代码比较速度的时候
我好多次看到了
Stopwatch watch1 = Stopwatch.StartNew();  这句话
我想到和我日常中用的Time.DeltaTime应该是一类东西
只不过这个可能更便捷更规范?
我自己想看看原码
然而我发现在Console下编程根本没有Time这个Unity中常用到的类
难道这个也是UnityEngine里面的东西?
没错 Time这个类的确是UnityEngine NameSpace下的
然而又是只读所以不能很清楚的知道到底是不是和StopWatch是Api同源
就没办法知道到底自己在Unity中是不是应该继续用Time.DeltaTime
不过总之还是很好地启发了我应该试试StopWatch
至少搜一搜它们之间的区别(🚄上没网有点小难受)
&amp;mdash;&amp;mdash;&amp;ndash;上网收获&amp;mdash;&amp;mdash;&amp;ndash;
查了一下发现没什么这两个东西有联系的网页
但是再次提醒了我 Time.DeltaTime指的是每帧的运行时长
Unity中之所以可以通过这种方法实现时间计算
是因为通过把运行的每帧的时间加起来得到的
和真实的时间是有区别的
计算可能完成但是渲染等其他计算耽误画面呈现从而让得到的时间往往比真实时间长一些
&amp;mdash;&amp;mdash;&amp;ndash;折了个腾&amp;mdash;&amp;mdash;&amp;ndash;
后来又看到了DateTime和StopWatch的争辩
发现这个事情大有可言
便搞了一阵儿
using System; using System.Diagnostics; using System.Threading; namespace TestInBook { internal class Program { public static void Main(string[] args) { // StopTimeTest(); // DateTimeTest(); Thread thread1 = new Thread(DateTimeTest); //线程1管DT Thread thread2 = new Thread(StopTimeTest); //线程1管SW Thread thread3 = new Thread(Cal2MethodDiff); //线程3管DT-SW thread1.</description>
    </item>
    
    <item>
      <title>未完待续_CSharp|ref &amp; out 参数的深入理解</title>
      <link>/post/2018/09/01/c-ref-out/</link>
      <pubDate>Sat, 01 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/2018/09/01/c-ref-out/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Python|Udacity_Python基础</title>
      <link>/post/2018/08/29/python-udacity-python/</link>
      <pubDate>Wed, 29 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/2018/08/29/python-udacity-python/</guid>
      <description>Day2 列表表达式 #基本语法：[expr for iter_var in iterable] #原型: &amp;gt;&amp;gt;&amp;gt; L= [] &amp;gt;&amp;gt;&amp;gt; for x in range(1 , 10): ... L.append(x*x) ... &amp;gt;&amp;gt;&amp;gt; L [1, 4, 9, 16, 25, 36, 49, 64, 81] #简化: &amp;gt;&amp;gt;&amp;gt; print [x*x for x in range(1 , 11)] [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] &amp;gt;&amp;gt;&amp;gt;  总结:
相当于把要 append的元素条件放在了[ ] 后的第一个位置
输出的仍然是一个列表
高级玩法
#加if: squares = [x**2 for x in range(9) if x % 2 == 0] #加if else: squares = [x**2 if x % 2 == 0 else x + 3 for x in range(9)]  总结:只有if for在前 if else for 在后</description>
    </item>
    
  </channel>
</rss>